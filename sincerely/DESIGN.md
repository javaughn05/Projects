The problem this project sought so solve was the lack of vulnerable connections that are made in competitive environments. I've noticed myself since getting to campus that people seemed closed off from one another, and sometimes, even from themselves. The academic rigor, high stress, and excessive ambition can lead individuals to negate their own personal problems, not to mention others. While this doesn't just apply to the Ivy League, for the scope of this project, that's who it targets. Talking to someone who relates and understands you is imperative. This app is made for those who are seeking out vulnerable, true friendships in a competitive and sometimes draining community.

The initial idea was to create a chat app that anonymously connected users from their own community. However, we've seen that before; Fizz, Reddit, Omegle (rip). I noticed the problems with these platforms were two fold: they were open to anyone and everyone to interact at all times, and beyond community, they had no way of filtering users. As well, anonyminity often becomes gossip (Fizz) when restricted to a singular community. To solve this and to ensure the security of users' identities, Sincerity matches users from alike but different communities.

Many match-making platforms are open, where users display their profile and make posts. This puts the responsiblity on behalf of the user to make connections. Instead, this app matchmakes for the user, and attempts to solve the ridiculously hard question to answer: "what makes two strangers compatible?" This project was designed to engage members of similiar communities in vulnerable conversations.

I first designed a register function which verified the TLD of user's domain to ensure they are apart of an Ivy-League school. After checking for errors like proper email and username inputs, etc. the user's username, password (hashed), email, and community are stored alongside a unique id in the "users" table via SQL in userbase.db. When a user inputs their scores, I call the login() function to automatically log users in. To accomplish these tasks, I used the Flask web framework for ease of use and functionality.

For matchmaking, this app uses psychology (see this study in particular: https://pubmed.ncbi.nlm.nih.gov/20433629/) to better filter compatible strangers with no effort on the users end. Simply talk. Share your story, don't be afraid to be honest, and speak from the heart.

Users can enter their Big Five personality test scores by accessing the score html page (which I send users to if they try to access the queue before inputting scores). I identified this page with a unqiue flask route, and wrote users scores into a "scores" SQL table with the users correlating ID and the scores (0-100) of all five of their OCEAN traits.

And now is the hard part. I wanted to use socket to allow users to connect and communicate in real-time. After tens of hours of logic testing, I finally found this method.

After users register, login, and enter scores they can then pair with a user. When the "go" button on the queue page is pressed, I emit a socket event to the client side which connects the user to an already built socket. When a user connects, their socket ID is temporarily associated with their flask ID in the users SQL table. A new div is shown, with a little spinning wheel indicating the user is being paired. They are also appended to a temporary list in Python which functions as a queue.

For now, this queue is set to 4, so users aren't just paired with the very next available user but have some kind of accuracy (which, in an ideal world, would only come with an extensive userbase). This queue can be expanded to higher numbers, set to a timer, or even be based on a minimum similarity threshold (this could be added to a function I will reference later).

Once the queue minimum is met, I iterate through the queue and give priority to those added first (been waiting the longest). I do this by first finding them an available room code using find_room(). I keep track of these codes in a SQL database called rooms which autoincrements and stores both the temprorary socket ids of the users in the room and the size of that room (available if 0, filled if 2). Within this function, I am able to either find an available room using the size field, or dynamically create new rooms if all rooms are filled. This way, I am also able to keep track of all user pairs server side in the SQL database.

I give priority to the first user by running the filter_users function during their index in the iteration. This function caculates which other active user (active users are found by checking non-null sid field in users table, shows they are active) has the least total difference across all their scores. This functions returns the socket id of the best matching user, and has both users join the room_code found by the priority user. Here is where a minimum similarity threshold could be implemented, only returning a matching_sid if it is below that threshold. I then append both these users from the queue as to ensure matched users who have already been paired don't try to pair again. By using a temporary list for the queue that works alongside the SQL databse opposed to functioning within the SQL database itself, I am able to continually keep track of active users, even if they are paired. This is neccesary for till the add contact feature within the chatroom itself.

Once users are paired, I display a new chatroom landing without sending the user to a new html page. This is done through the queued_success socket emit.

All server side code is built in Python, and all client side events are handled in javascript. Socket connects the two, and allows the client to communicate with the server, which responds to changes of the other clients.

If a user disconnects, all databases are updated and both users are sent out of the room with the resulting client html being updated. As well, I ensure if a user disconnects while queuing before they have been paired, the server-side database is updated and they are removed from the queue.

Within the chatroom, new messages are handled when a user enters a value and clicks the "enter" key. This is heard and reflected with a message and username field. Similiar logic is used for the add-friend button, which keeps track of users' paired contacts in a SQL table called friends. This could be used later to create private rooms, and more intelligently pair users based off previous successful matches.

The styling was built in Figma, which I then converted to fit my functionality.
